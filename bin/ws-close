#!/usr/bin/env bash
# ws-close â€” sluit alle vensters in een workspace
set -euo pipefail

WORKSPACE=""
FORCE=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -w|--workspace) WORKSPACE="$2"; shift 2 ;;
    -f|--force) FORCE=true; shift ;;
    *) echo "Usage: $0 --workspace <number> [--force]"; exit 1 ;;
  esac
done

[[ -n "$WORKSPACE" ]] || { echo "Error: geen workspace opgegeven"; exit 1; }

AERO_BIN="${AERO_BIN:-$(command -v aerospace || true)}"
[[ -n "$AERO_BIN" ]] || { echo "aerospace niet gevonden" >&2; exit 1; }
aero() { "$AERO_BIN" "$@"; }

echo "== Sluiting workspace $WORKSPACE =="

# Haal alle venster IDs op in deze workspace
WINDOW_IDS=($(aero list-windows --workspace "$WORKSPACE" --format '%{window-id}' 2>/dev/null || true))

if [[ ${#WINDOW_IDS[@]} -eq 0 ]]; then
  echo "Geen vensters gevonden in workspace $WORKSPACE"
  exit 0
fi

echo "Gevonden ${#WINDOW_IDS[@]} venster(s) in workspace $WORKSPACE"

# Sluit elk venster
for wid in "${WINDOW_IDS[@]}"; do
  if [[ -n "$wid" ]]; then
    # Haal app informatie op door alle vensters te scannen
    APP_INFO=$(aero list-windows --workspace "$WORKSPACE" --format '%{window-id} %{app-bundle-id}' | grep "^$wid " | awk '{print $2}' || echo "unknown")
    
    echo "Sluiting venster $wid ($APP_INFO)..."
    
    # Speciale behandeling voor verschillende apps
    case "$APP_INFO" in
      com.mitchellh.ghostty)
        echo "Ghostty detected..."
        # Normale sluiting (confirmation dialog is uitgeschakeld)
        aero close --window-id "$wid" 2>/dev/null || true
        ;;
      com.jetbrains.rubymine)
        echo "RubyMine detected..."
        # Haal de PID van deze RubyMine instantie op
        RUBYMINE_PID=$(ps aux | grep -E "rubymine|RubyMine" | grep -v grep | awk '{print $2}' | head -1)
        
        # Voor RubyMine: sluit altijd de hele app om welcome screens te voorkomen
        echo "RubyMine gedetecteerd - sluiting hele app om welcome screens te voorkomen..."
        osascript -e 'quit app "RubyMine"' 2>/dev/null || true
        sleep 1
        # Force kill als het niet werkt
        if aero list-windows --workspace "$WORKSPACE" | grep -q "^$wid "; then
          pkill -f "rubymine" 2>/dev/null || true
        fi
        
        # Detecteer het project pad uit de RubyMine argumenten
        PROJECT_PATH=""
        if [[ -n "$RUBYMINE_PID" ]]; then
          # Haal het project pad op uit de RubyMine command line
          PROJECT_PATH=$(ps -p "$RUBYMINE_PID" -o args= 2>/dev/null | grep -o '/[^[:space:]]*$' || true)
          if [[ -n "$PROJECT_PATH" && -d "$PROJECT_PATH" ]]; then
            PROJECT_NAME=$(basename "$PROJECT_PATH")
            echo "Gedetecteerd project: $PROJECT_NAME in $PROJECT_PATH"
          fi
        fi
        
        # Sluit Ruby processen die child processen zijn van deze RubyMine instantie
        if [[ -n "$RUBYMINE_PID" ]]; then
          echo "Zoeken naar Ruby processen gestart door RubyMine PID $RUBYMINE_PID..."
          # Zoek child processen recursief
          CHILD_PIDS=$(pgrep -P "$RUBYMINE_PID" 2>/dev/null || true)
          for child_pid in $CHILD_PIDS; do
            # Check of het een Ruby proces is
            if ps -p "$child_pid" -o comm= 2>/dev/null | grep -q ruby; then
              echo "Sluiting Ruby child proces $child_pid..."
              kill -TERM "$child_pid" 2>/dev/null || true
            fi
            # Check ook grandchildren (Ruby servers gestart via shell)
            GRANDCHILD_PIDS=$(pgrep -P "$child_pid" 2>/dev/null || true)
            for grandchild_pid in $GRANDCHILD_PIDS; do
              if ps -p "$grandchild_pid" -o comm= 2>/dev/null | grep -q ruby; then
                echo "Sluiting Ruby grandchild proces $grandchild_pid..."
                kill -TERM "$grandchild_pid" 2>/dev/null || true
              fi
            done
          done
        fi
          
        # UITGEBREIDE CLEANUP: Alle Rails/Ruby server processen voor dit project
        echo "Uitgebreide cleanup van alle development server processen..."
        
        # Sluit alle puma/rails server processen (onafhankelijk van parent PID)
        echo "Cleanup puma servers..."
        pkill -f "puma.*3000" 2>/dev/null || true
        pkill -f "rails server" 2>/dev/null || true
        pkill -f "rails s" 2>/dev/null || true
        
        # Als we een project naam hebben, clean specifiek voor dat project
        if [[ -n "$PROJECT_NAME" ]]; then
          echo "Cleanup processen voor project $PROJECT_NAME..."
          pkill -f "puma.*$PROJECT_NAME" 2>/dev/null || true
          pkill -f "rails.*$PROJECT_NAME" 2>/dev/null || true
          pkill -f "sidekiq.*$PROJECT_NAME" 2>/dev/null || true
          pkill -f "fsevent_watch.*$PROJECT_NAME" 2>/dev/null || true
          pkill -f "rb-fsevent.*$PROJECT_NAME" 2>/dev/null || true
          
          # Ook Node.js development servers (webpack-dev-server, etc.)
          echo "Cleanup Node.js development servers voor $PROJECT_NAME..."
          pkill -f "webpack-dev-server.*$PROJECT_NAME" 2>/dev/null || true
          pkill -f "node.*$PROJECT_NAME.*webpack" 2>/dev/null || true
          pkill -f "vite.*$PROJECT_NAME" 2>/dev/null || true
        fi
        
        # Extra cleanup: zoek naar fsevent_watch processen
        echo "Cleanup file watching processen..."
        pkill -f "fsevent_watch" 2>/dev/null || true
        pkill -f "rb-fsevent" 2>/dev/null || true
        
        # Wacht even en probeer nog resterende Ruby processen op te ruimen
        sleep 1
        
        # Check voor overgebleven Ruby server processen
        REMAINING_SERVERS=$(ps aux | grep -E "(puma|rails server|sidekiq)" | grep -v grep | awk '{print $2}' || true)
        if [[ -n "$REMAINING_SERVERS" ]]; then
          echo "Cleanup overgebleven server processen..."
          for pid in $REMAINING_SERVERS; do
            echo "Force kill server proces $pid..."
            kill -KILL "$pid" 2>/dev/null || true
          done
        fi
        ;;
      com.apple.Terminal|com.googlecode.iterm2)
        echo "Terminal app detected, using force close..."
        aero close --window-id "$wid" 2>/dev/null || true
        ;;
      *)
        # Voor andere apps: normale sluiting
        if [[ "$FORCE" == "true" ]]; then
          aero close --window-id "$wid" 2>/dev/null || true
        else
          aero close --window-id "$wid" 2>/dev/null || true
        fi
        ;;
    esac
    sleep 0.1
  fi
done

# Laatste check: sluit eventuele overgebleven welcome vensters
echo "Laatste check voor achtergebleven vensters..."
REMAINING_WELCOME=$(aero list-windows --workspace "$WORKSPACE" 2>/dev/null | grep -i "Welcome to" | wc -l | tr -d ' \n' || echo "0")

if [[ "$REMAINING_WELCOME" -gt 0 ]]; then
  echo "Er zijn nog $REMAINING_WELCOME welcome venster(s) - force quit van JetBrains apps..."
  osascript -e 'quit app "RubyMine"' 2>/dev/null || true
  pkill -f "rubymine" 2>/dev/null || true
  sleep 1
  # Check nogmaals en force close individuele vensters
  aero list-windows --workspace "$WORKSPACE" --format '%{window-id}' 2>/dev/null | while read -r wid; do
    if [[ -n "$wid" ]]; then
      aero close --window-id "$wid" 2>/dev/null || true
    fi
  done
else
  echo "Alle vensters succesvol gesloten."
fi

echo "== Workspace $WORKSPACE gesloten =="
